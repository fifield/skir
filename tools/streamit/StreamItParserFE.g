/*
 * Copyright 2003 by the Massachusetts Institute of Technology.
 *
 * Permission to use, copy, modify, and distribute this
 * software and its documentation for any purpose and without
 * fee is hereby granted, provided that the above copyright
 * notice appear in all copies and that both that copyright
 * notice and this permission notice appear in supporting
 * documentation, and that the name of M.I.T. not be used in
 * advertising or publicity pertaining to distribution of the
 * software without specific, written prior permission.
 * M.I.T. makes no representations about the suitability of
 * this software for any purpose.  It is provided "as is"
 * without express or implied warranty. 
 */

/*
 * StreamItParserFE.g: StreamIt parser producing front-end tree
 * $Id: StreamItParserFE.g,v 1.64 2006/08/23 23:01:03 thies Exp $
 */

header {
#include <antlr/Token.hpp>
#include "nodes/Nodes.hpp"
#include <cmath>

using namespace streamit;

}
options {
    language="Cpp";
}
    
class StreamItParserFE extends Parser;

options {
	importVocab=StreamItLex;	// use vocab generated by lexer
}

{
public:
    FEContext *getContext(ANTLR_USE_NAMESPACE(antlr)Token *t)
    {
        int line = t->getLine();
        if (line == 0) line = -1;
        int col = t->getColumn();
        if (col == 0) col = -1;
        return new FEContext(getFilename(), line, col);
    }
    
    bool hasError;

// 	public void reportError(RecognitionException ex)
// 	{
// 		hasError = true;
// 		super.reportError(ex);
// 	}

// 	public void  reportError(String s)
// 	{
// 		hasError = true;
// 		super.reportError(s);
// 	}
}

program	returns [Program *p]
{ p = NULL;
  hasError = false;
  TypeStructList *structs = new TypeStructList;
  StreamSpecList *streams = new StreamSpecList;
  TypeHelperList *helpers = new TypeHelperList;
  TypeStruct *ts; StreamSpec *ss; TypeHelper *th; }
 	:	( ts=struct_decl { structs->push_back(ts); }
 		| ss=stream_decl { streams->push_back(ss); }
 		| th=native_decl { helpers->push_back(th); }
 		| th=helper_decl { helpers->push_back(th); }
        | ss=global_decl { streams->push_back(ss); }
    )*
	EOF
		// Can get away with no context here.
		{ if (!hasError) p = new Program(NULL, streams, structs, helpers); }
	;

 stream_decl returns [StreamSpec *ss] { ss = NULL; StreamType *st; }
 :	st=stream_type_decl
    (ss=filter_decl[st] | ss=struct_stream_decl[st])
 	;

global_decl returns [StreamSpec *ss] 
{ ss = NULL; FEContext *context = NULL; StreamSpec *body; }
 	:	tg:TK_static
 		{ context = getContext(tg); }
 		body=global_body[context]
 		{ ss = body; }
 	;

global_body[FEContext *context] returns [StreamSpec *ss] 
{ ss = NULL; FieldDeclList *vars = new FieldDeclList; FunctionList *funcs = new FunctionList;
  Function *fn; FieldDecl *decl; }
 	:	LCURLY
         ( decl=field_decl SEMI { vars->push_back(decl); })* 
         ( fn=init_decl { funcs->push_back(fn); } )?
         RCURLY
         { StreamType *st = new StreamType(context, 
  		                           new TypePrimitive(TypePrimitive::TYPE_VOID),
 		                           new TypePrimitive(TypePrimitive::TYPE_VOID));
           ss = new StreamSpec(context, StreamSpec::STREAM_GLOBAL, st,
                               "TheGlobal", new ParameterList,
                               vars, funcs); }
         ; 

// //?????
// // 		( (global_statement) => s=global_statement { if (s != NULL) init.add(s); } 
// // 		| decl=field_decl SEMI { 

// // 			// need to separate initializers from field
// // 			// declarations to ensure that initializations
// // 			// are performed in the correct order!

// // 			FEContext ctx = decl.getContext();
// // 			int num = decl.getNumFields();

// // 			List names = decl.getNames();
// // 			List types = decl.getTypes();
// // 			List inits = decl.getInits();
// // 			List new_inits = new ArrayList(num);

// // 			for (int i = 0; i < num; i++) {
// // 				Expression iexpr = (Expression)inits.get(i);
// // 				if (iexpr != NULL) {
// // 					init.add(new StmtAssign(ctx, 
// // 						new ExprVar(ctx, (String)names.get(i)),
// // 						iexpr));
// // 				}
// // 				new_inits.add(NULL);
// // 			}

// // 			vars.add(new FieldDecl(ctx, types, names, new_inits)); 

// // 		}
// // 		)* 
// // 		RCURLY
// // 		{ 
// // 	StreamType st = new StreamType(context, 
// // 		new TypePrimitive(TypePrimitive.TYPE_VOID),
// // 		new TypePrimitive(TypePrimitive.TYPE_VOID));	
// // 	ss = new StreamSpec(context, StreamSpec.STREAM_GLOBAL,
// // 				st, "TheGlobal", Collections.EMPTY_LIST, vars,
// // 				Collections.singletonList(Function.newInit(context, new StmtBlock(getContext(t), init))));
// // 		}
// // 	;

// global_statement returns [Statement s] { s = NULL; }
// 	:	(expr_statement) => s=expr_statement SEMI! 
// 	|	s=if_else_statement
// 	|	s=while_statement
// 	|	s=do_while_statement SEMI
// 	|	s=for_statement
// 	|       (ID DOT ID LPAREN) => s=helper_call_statement SEMI
// 	|	SEMI
// 	;	

/// XXX params could leak here
filter_decl[StreamType *st] returns [StreamSpec *ss]
{ ss = NULL; ParameterList *params = new ParameterList; FEContext *context = NULL; }
    :	tf:TK_filter
 		{ if (st != NULL) context = st->getContext();
 			else context = getContext(tf); }
 		id:ID
		(params=param_decl_list)?
 		ss=filter_body[context, st, id->getText(), params]
 	;

filter_body[FEContext *context, StreamType *st, string name, ParameterList *params]
returns [StreamSpec *ss]
{ ss = NULL; FieldDeclList *vars = new FieldDeclList(); FunctionList *funcs = new FunctionList();
    Function *fn; FieldDecl *decl; }
    :	LCURLY
 		( fn=init_decl { funcs->push_back(fn); }
 		| fn=work_decl { funcs->push_back(fn); }
 		| (data_type ID LPAREN) => fn=function_decl { funcs->push_back(fn); }
 		| fn=handler_decl { funcs->push_back(fn); }
 		| decl=field_decl SEMI { vars->push_back(decl); }
 		)*
 		RCURLY
 		{ ss = new StreamSpec(context, StreamSpec::STREAM_FILTER,
 				st, name, params, vars, funcs); }
 	;

field_decl returns [FieldDecl *f] { f = NULL; Type *t; Expression *x = NULL;
 	TypeList *ts = new TypeList; NameList *ns = new NameList;
 	ExpressionList *xs = new ExpressionList; FEContext *ctx = NULL; }
 	:	t=data_type id:ID (ASSIGN x=var_initializer)?
 		{ ctx = getContext(id); ts->push_back(t); ns->push_back(id->getText()); xs->push_back(x); }
 		(
 			{ x = NULL; }
 			COMMA id2:ID (ASSIGN x=var_initializer)?
 			{ ts->push_back(t); ns->push_back(id2->getText()); xs->push_back(x); }
 		)*
 		{ f = new FieldDecl(ctx, ts, ns, xs); }
 	;


stream_type_decl returns [StreamType *st] { st = NULL; Type *in, *out; }
 	:	in=data_type t:ARROW out=data_type
 		// Again, want context from the input type, but Types aren't
 		// FENodes.
 		{ st = new StreamType(getContext(t), in, out); }
 	;

// XXX params could leak
struct_stream_decl[StreamType *st] returns [StreamSpec *ss]
{ ss = NULL; int type = 0;
	ParameterList *params = new ParameterList; Statement *body; }
 	:	( TK_pipeline { type = StreamSpec::STREAM_PIPELINE; }
 		| TK_splitjoin { type = StreamSpec::STREAM_SPLITJOIN; }
 		| TK_feedbackloop { type = StreamSpec::STREAM_FEEDBACKLOOP; }
 		)
		id:ID
		(params=param_decl_list)?
		body=block
		{ ss = new StreamSpec(st->getContext(), type, st, id->getText(),
				params, body); }
	;

work_decl returns [FuncWork *f]
{	f = NULL;
 	Expression *pop = NULL, *peek = NULL, *push = NULL;
	Statement *s; FEContext *c = NULL; string name;
 	int type = 0;
}
 	:	(	tw:TK_work { c = getContext(tw); type = Function::FUNC_WORK; }
 		|	tpw:TK_prework { c = getContext(tpw);
 							 type = Function::FUNC_PREWORK; }
 		)
 		(	TK_push push=rate_expr
 		|	TK_pop pop=rate_expr
 		|	TK_peek peek=rate_expr
 		)*
 		s=block
 		{ f = new FuncWork(c, type, name, s, peek, pop, push); }
 	;

// returns either a range or a dynamic expression
rate_expr returns [Expression *e]  { e = NULL; }
 	:	( s:STAR {// convert plain '*' to range '[*,*,*]' for consistency with SIR + library
                 e = new ExprRange(getContext(s),
                     new ExprDynamicToken(getContext(s)),
                     new ExprDynamicToken(getContext(s)),
                     new ExprDynamicToken(getContext(s))); } )
         | e=range_expr
         | e=right_expr
 	;

// // returns a range, like [min, ave, max]
range_expr returns [Expression *e]
{
    e = NULL;
    FEContext *c = NULL;
    Expression *min = NULL, *r2 = NULL, *r3 = NULL; 
}   : ( l:LSQUARE { c = getContext(l); }
            min=dynamic_expr COMMA 
            // even though it's really the second argument that is
            // optional, have to write it this way to avoid ambiguity in
            // the parsing
            r2=dynamic_expr (COMMA r3=dynamic_expr)?
          RSQUARE
        )
        { Expression *ave, *max;
            if (r3==NULL) {
                ave = NULL;
                max = r2;
            } else {
                ave = r2;
                max = r3;
            }
            e = new ExprRange(c, min, ave, max); 
        }
    ;

// returns a dynamic expression, which is either a plain (right)
// expression or '*'
dynamic_expr returns [Expression *e]
{
    e = NULL;
}   : ( s:STAR {e = new ExprDynamicToken(getContext(s)); } )
    | e=right_expr
    ;

init_decl returns [Function *f] { Statement *s; f = NULL; }
 	:	t:TK_init s=block { f = Function::newInit(getContext(t), s); }
 	;

push_statement returns [Statement *s] { s = NULL; Expression *x; }
 	:	t:TK_push LPAREN x=right_expr RPAREN
 		{ s = new StmtPush(getContext(t), x); }
 	;

helper_call_statement	returns [Statement *s] { s = NULL; ExpressionList *l; }
	:	p:ID DOT m:ID l=func_call_params
		{ s = new StmtHelperCall(getContext(p), p->getText(), m->getText(), l); }
	;

// msg_statement returns [Statement s] { s = NULL; List l;
//   Expression minl = NULL, maxl = NULL; boolean var = false;}
// 	:	p:ID DOT m:ID l=func_call_params
// 		(LSQUARE 
// 			((minl=right_expr)? COLON (maxl=right_expr)?
// 			 | STAR { var = true; }
// 			 ) 
// 		 RSQUARE)?
// 		{   if (! var) {
// 		 		if (minl == NULL) { minl = new ExprConstInt(0);}
// 				if (maxl == NULL) { maxl = minl; }
// 		    }
// 			s = new StmtSendMessage(getContext(p),
// 				new ExprVar(getContext(p), p.getText()),
// 				m.getText(), l, minl, maxl); }
// 	;

statement returns [Statement *s] { s = NULL; }
 	:	s=add_statement
 	|	s=body_statement
 	| 	s=loop_statement
 	|	s=split_statement SEMI
 	|	s=join_statement SEMI
// 	|	s=enqueue_statement SEMI
 	|	s=push_statement SEMI
 	|	s=block
 	|	(data_type ID) => s=variable_decl SEMI!
 	|	(expr_statement) => s=expr_statement SEMI!
 	|	tb:TK_break SEMI { s = new StmtBreak(getContext(tb)); }
 	|	tc:TK_continue SEMI { s = new StmtContinue(getContext(tc)); }
 	|	s=return_statement SEMI
	|	s=if_else_statement
 	|	s=while_statement
 	|	s=do_while_statement SEMI
 	|	s=for_statement
// 	|	s=msg_statement SEMI
// /*	|       (ID DOT ID LPAREN) => s=helper_call_statement SEMI */
 	|   SEMI
 	;

add_statement returns [Statement *s] { s = NULL; StreamCreator *sc; }
 	: t:TK_add sc=stream_creator { s = new StmtAdd(getContext(t), sc); }
 	;

body_statement returns [Statement *s] { s = NULL; StreamCreator *sc; }
 	: t:TK_body sc=stream_creator { s = new StmtBody(getContext(t), sc); }
 	;

loop_statement returns [Statement *s] { s = NULL; StreamCreator *sc; }
 	: t:TK_loop sc=stream_creator { s = new StmtLoop(getContext(t), sc); }
 	;

stream_creator returns [StreamCreator *sc] { sc = NULL; }
 	: (ID ARROW | ~ID) => sc=anonymous_stream
 	| sc=named_stream SEMI
 	;

portal_spec returns [ExpressionList *p] { p = new ExpressionList; /*Expression *pn;*/ }
 	:	TK_to 
         id:ID { p->push_back(new ExprVar(getContext(id), id->getText())); }
         (COMMA id2:ID { p->push_back(new ExprVar(getContext(id2), id2->getText())); })*
 	;

anonymous_stream returns [StreamCreator *sc]
{ sc = NULL; StreamType *st = NULL; /*ParameterList *params = new ParameterList;*/
  Statement *body; /*TypeList *types = new TypeList; Type *t;*/ StreamSpec *ss = NULL;
  ExpressionList *p = NULL; int sst = 0; FEContext *ctx = NULL; }
// XXX require type (for now_
 	: (st=stream_type_decl)
 		( tf:TK_filter
 			ss=filter_body[getContext(tf), st, string("anon"), new ParameterList]
 			((p=portal_spec)? SEMI)?
 			{ sc = new SCAnon(getContext(tf), ss, p); }
 		|	( tp:TK_pipeline
 				{ ctx = getContext(tp); sst = StreamSpec::STREAM_PIPELINE; }
 			| ts:TK_splitjoin
 				{ ctx = getContext(ts); sst = StreamSpec::STREAM_SPLITJOIN; }
 			| tl:TK_feedbackloop
 				{ ctx = getContext(tl); sst = StreamSpec::STREAM_FEEDBACKLOOP; }
 			) body=block ((p=portal_spec)? SEMI)?
 			{ ss = new StreamSpec(ctx, sst, st, string("anon"), new ParameterList, body);
              sc = new SCAnon(ctx, ss, p); }
 		)
 	;

named_stream returns [StreamCreator *sc]
{ sc = NULL; ExpressionList *params = new ExpressionList; TypeList *types = new TypeList;
  Type *t; ExpressionList *p = NULL; }
 	: id:ID
 		(LESS_THAN t=data_type MORE_THAN { types->push_back(t); })?
 		(params=func_call_params)?
 		(p=portal_spec)?
 		{ sc = new SCSimple(getContext(id), id->getText(), types, params, p); }
 	;

split_statement returns [Statement *s] { s = NULL; SplitterJoiner *sj; }
 	: t:TK_split sj=splitter_or_joiner
 		{ s = new StmtSplit(getContext(t), sj); }
 	;

join_statement returns [Statement *s] { s = NULL; SplitterJoiner *sj; }
 	: t:TK_join sj=splitter_or_joiner
 		{ s = new StmtJoin(getContext(t), sj); }
 	;

splitter_or_joiner returns [SplitterJoiner *sj]
{ sj = NULL; Expression *x; ExpressionList *l; }
	: tr:TK_roundrobin
		( (LPAREN RPAREN) => LPAREN RPAREN
			{ sj = new SJRoundRobin(getContext(tr)); }
		| (LPAREN right_expr RPAREN) => LPAREN x=right_expr RPAREN
			{ sj = new SJRoundRobin(getContext(tr), x); }
		| l=func_call_params { sj = new SJWeightedRR(getContext(tr), l); }
		| { sj = new SJRoundRobin(getContext(tr)); }
		)
	| td:TK_duplicate (LPAREN RPAREN)?
		{ sj = new SJDuplicate(getContext(td)); }
	;

// enqueue_statement returns [Statement s] { s = NULL; Expression x; }
// 	: t:TK_enqueue x=right_expr { s = new StmtEnqueue(getContext(t), x); }
// 	;

data_type returns [Type *t] { t = NULL; /*Type *primitive = NULL;*/ Expression *x; 
    ExpressionList *lengths = new ExpressionList; }
 	:	(t=primitive_type | id:ID { t = new TypeStructRef(id->getText()); })
		(	l:LSQUARE
			(x=right_expr { lengths->push_back(x); }
// 			| { throw new SemanticException("missing array bounds in type declaration", getFilename(), l.getLine()); }
			| { assert("missing array bounds in type declaration" && 0); }
			)
			RSQUARE
		)* 
        // want nesting of types with left-most type highest, even
        // though parser gives right-most type at top of hierarchy
        {
            for (int i=lengths->size()-1; i>=0; i--) {\
                t = new TypeArray(t, (Expression*)(lengths->at(i)));
            }
        }
 	|	TK_void { t = new TypePrimitive(TypePrimitive::TYPE_VOID); }
// 	|	TK_portal LESS_THAN pn:ID MORE_THAN
// 		{ t = new TypePortal(pn.getText()); }
 	;

 primitive_type returns [Type *t] { t = NULL; }
 	:	TK_boolean { t = new TypePrimitive(TypePrimitive::TYPE_BOOLEAN); }
 	|	TK_bit { t = new TypePrimitive(TypePrimitive::TYPE_BIT); }
 	|	TK_int { t = new TypePrimitive(TypePrimitive::TYPE_INT); }
 	|	TK_float { t = new TypePrimitive(TypePrimitive::TYPE_FLOAT); }
 	|	TK_double { t =  new TypePrimitive(TypePrimitive::TYPE_DOUBLE); }
 	|	TK_complex { t = new TypePrimitive(TypePrimitive::TYPE_COMPLEX); }
 	|	TK_float2 { t = new TypePrimitive(TypePrimitive::TYPE_FLOAT2); }
 	|	TK_float3 { t = new TypePrimitive(TypePrimitive::TYPE_FLOAT3); }
 	|	TK_float4 { t = new TypePrimitive(TypePrimitive::TYPE_FLOAT4); }
 	;

variable_decl returns [Statement *s] { s = NULL; Type *t; Expression *x = NULL; 
 	TypeList *ts = new TypeList; NameList *ns = new NameList;
 	ExpressionList *xs = new ExpressionList; FEContext *ctx = NULL; }
 	:	t=data_type
		id:ID { ctx = getContext(id); }
		(ASSIGN x=var_initializer)?
		{ ts->push_back(t); ns->push_back(id->getText()); xs->push_back(x); }
		(
			{ x = NULL; }
			COMMA id2:ID (ASSIGN x=var_initializer)?
			{ ts->push_back(t); ns->push_back(id2->getText()); xs->push_back(x); }
		)*
		{ s = new StmtVarDecl(ctx, ts, ns, xs); }
		// NB: we'd use the context of t, except Type doesn't include
		// a context.  This is probably okay in the grand scheme of things.
		// We explicitly use the context of the first identifier.
	;

function_decl returns [Function *f] 
{ 
    Type *t; ParameterList *l; Statement *s; f = NULL;
    int cls = Function::FUNC_HELPER;
 	Expression *pop = NULL, *peek = NULL, *push = NULL;
}
 	:	t=data_type id:ID 
        l=param_decl_list 
		(	TK_push push=rate_expr
 		|	TK_pop pop=rate_expr
 		|	TK_peek peek=rate_expr
 		)*
        s=block
 		{ f = new Function(getContext(id), cls, id->getText(), t, l, s, peek, pop, push); }
 	;

handler_decl returns [Function *f] { ParameterList *l; Statement *s; f = NULL;
  Type *t = new TypePrimitive(TypePrimitive::TYPE_VOID);
  int cls = Function::FUNC_HANDLER; }
 	:	TK_handler id:ID l=param_decl_list s=block
 		{ f = new Function(getContext(id), cls, id->getText(), t, l, s, NULL, NULL, NULL); }
 	;

param_decl_list returns [ParameterList *l] { l = new ParameterList; Parameter *p; }
 	:	LPAREN
 		(p=param_decl { l->push_back(p); } (COMMA p=param_decl { l->push_back(p); })*
 		)?
 		RPAREN
 	;

param_decl returns [Parameter *p] { Type *t; p = NULL; }
 	:	t=data_type id:ID { p = new Parameter(t, id->getText()); }
 	;

block returns [Statement *s] { s = NULL; StatementList *l = new StatementList; }
 	:	t:LCURLY ( s=statement { if (s != NULL) l->push_back(s); } )* RCURLY
 		{ s = new StmtBlock(getContext(t), l); }
 	;

return_statement returns [Statement *s] { s = NULL; Expression *x = NULL; }
 	:	t:TK_return (x=right_expr)? { s = new StmtReturn(getContext(t), x); }
 	;

if_else_statement returns [Statement *s]
{ s = NULL; Expression *x; Statement *t, *f = NULL; }
	:	u:TK_if LPAREN x=right_expr RPAREN t=statement
		((TK_else) => (TK_else f=statement))?
		{ s = new StmtIfThen(getContext(u), x, t, f); }
	;

while_statement returns [Statement *s] { s = NULL; Expression *x; Statement *b; }
	:	t:TK_while LPAREN x=right_expr RPAREN b=statement
		{ s = new StmtWhile(getContext(t), x, b); }
	;

do_while_statement returns [Statement *s]
{ s = NULL; Expression *x; Statement *b; }
	:	t:TK_do b=statement TK_while LPAREN x=right_expr RPAREN
		{ s = new StmtDoWhile(getContext(t), b, x); }
	;

for_statement returns [Statement *s]
{ s = NULL; Expression *x=NULL; Statement *a, *b, *c; }
	:	t:TK_for LPAREN a=for_init_statement SEMI
		(x=right_expr | { x = new ExprConstBoolean(getContext(t), true); })
		SEMI b=for_incr_statement RPAREN c=statement
		{ s = new StmtFor(getContext(t), a, x, b, c); }
	;

for_init_statement returns [Statement *s] { s = NULL; }
	:	(variable_decl) => s=variable_decl
	|	(expr_statement) => s=expr_statement
	|   (SEMI) /* empty */ => { s = new StmtEmpty(NULL); }
	;

for_incr_statement returns [Statement *s] { s = NULL; }
	:	s=expr_statement
	|   /* empty */ { s = new StmtEmpty(NULL); }
	;

expr_statement returns [Statement *s] { s = NULL; Expression *x; }
 	:	(incOrDec) => x=incOrDec { s = new StmtExpr(x); }
 	|   (left_expr (ASSIGN | PLUS_EQUALS | MINUS_EQUALS | STAR_EQUALS |
 				DIV_EQUALS | LSHIFT_EQUALS | RSHIFT_EQUALS)) => s=assign_expr
 	|	(ID LPAREN) => x=func_call { s = new StmtExpr(x); }
 	|	x=streamit_value_expr { s = new StmtExpr(x); }
 	;

assign_expr returns [Statement *s] { s = NULL; Expression *l, *r; int o = 0; }
	:	l=left_expr
		(	ASSIGN { o = 0; }
		|	PLUS_EQUALS { o = ExprBinary::BINOP_ADD; }
		| 	MINUS_EQUALS { o = ExprBinary::BINOP_SUB; }
		|	STAR_EQUALS { o = ExprBinary::BINOP_MUL; }
		|	DIV_EQUALS { o = ExprBinary::BINOP_DIV; }
        |   LSHIFT_EQUALS { o = ExprBinary::BINOP_LSHIFT; }
        |   RSHIFT_EQUALS { o = ExprBinary::BINOP_RSHIFT; }
		)
		r=right_expr
		{ s = new StmtAssign(l->getContext(), l, r, o); }
	;

func_call returns [Expression *x] { x = NULL; ExpressionList *l; }
 	:	name:ID l=func_call_params
 		{ x = new ExprFunCall(getContext(name), name->getText(), l); }
 	;

helper_call	returns [Expression *x] { x = NULL; ExpressionList *l; }
	:	p:ID DOT m:ID l=func_call_params
		{ x = new ExprHelperCall(getContext(p), p->getText(), m->getText(), l); }
	;

func_call_params returns [ExpressionList *l] { l = new ExpressionList; Expression *x; }
 	:	LPAREN
 		(	x=right_expr { l->push_back(x); }
 			(COMMA x=right_expr { l->push_back(x); })*
 		)?
 		RPAREN
 	;

left_expr returns [Expression *x] { x = NULL; }
 	:	x=value
 	;

right_expr returns [Expression *x] { x = NULL; }
 	: x=ternaryExpr
 	| x=float2_initializer
    | x=float3_initializer
    | x=float4_initializer
 	;
	
float2_initializer returns [Expression *x] { x = NULL; Expression *p1, *p2; }
 	:	lc:TK_float2 LPAREN p1=right_expr COMMA p2=right_expr RPAREN 
 	    { x = new ExprComposite(getContext(lc), p1, p2, NULL, NULL); } 
 	;	

float3_initializer returns [Expression *x] { x = NULL; Expression *p1, *p2, *p3; }
 	:	lc:TK_float3 LPAREN p1=right_expr COMMA p2=right_expr COMMA p3=right_expr RPAREN 
 	    { x = new ExprComposite(getContext(lc), p1, p2, p3, NULL); } 
 	;	
	
float4_initializer returns [Expression *x] { x = NULL; Expression *p1, *p2, *p3, *p4; }
 	:	lc:TK_float4 LPAREN p1=right_expr COMMA p2=right_expr COMMA p3=right_expr COMMA p4=right_expr RPAREN 
 	    { x = new ExprComposite(getContext(lc), p1, p2, p3, p4); } 
 	;

var_initializer returns [Expression *x] { x = NULL; }
 	: x=right_expr
    | x=arr_initializer
 	;

arr_initializer returns [Expression *x] { ExpressionList *l = new ExpressionList;
                                         x = NULL;
                                         Expression *y; }
    : lc:LCURLY
      ( y=var_initializer { l->push_back(y); }
            (COMMA y=var_initializer { l->push_back(y); })*
      )?
      RCURLY
      { x = new ExprArrayInit(getContext(lc), l); } 
    ;

ternaryExpr returns [Expression *x] { x = NULL; Expression *b, *c; }
 	:	x=logicOrExpr
 		(QUESTION b=ternaryExpr COLON c=ternaryExpr
 			{ x = new ExprTernary(x->getContext(), ExprTernary::TEROP_COND,
 					x, b, c); }
 		)?
 	;

logicOrExpr returns [Expression *x] { x = NULL; Expression *r; }
 	:	x=logicAndExpr
 		(LOGIC_OR r=logicAndExpr
 			{ x = new ExprBinary(x->getContext(), ExprBinary::BINOP_OR, x, r); }
 		)*
 	;

logicAndExpr returns [Expression *x] { x = NULL; Expression *r; }
 	:	x=bitwiseExpr
 		(LOGIC_AND r=bitwiseExpr
 			{ x = new ExprBinary(x->getContext(), ExprBinary::BINOP_AND, x, r); }
 		)*
 	;

bitwiseExpr returns [Expression *x] { x = NULL; Expression *r; int o = 0; }
 	:	x=equalExpr
 		(	( BITWISE_OR  { o = ExprBinary::BINOP_BOR; }
 			| BITWISE_AND { o = ExprBinary::BINOP_BAND; }
 			| BITWISE_XOR { o = ExprBinary::BINOP_BXOR; }
 			)
 			r=equalExpr
 			{ x = new ExprBinary(x->getContext(), o, x, r); }
 		)*
 	;

equalExpr returns [Expression *x] { x = NULL; Expression *r; int o = 0; }
 	:	x=compareExpr
 		(	( EQUAL     { o = ExprBinary::BINOP_EQ; }
 			| NOT_EQUAL { o = ExprBinary::BINOP_NEQ; }
 			)
 			r = compareExpr
 			{ x = new ExprBinary(x->getContext(), o, x, r); }
 		)*
 	;

compareExpr returns [Expression *x] { x = NULL; Expression *r; int o = 0; }
 	:	x=addExpr
 		(	( LESS_THAN  { o = ExprBinary::BINOP_LT; }
 			| LESS_EQUAL { o = ExprBinary::BINOP_LE; }
 			| MORE_THAN  { o = ExprBinary::BINOP_GT; }
 			| MORE_EQUAL { o = ExprBinary::BINOP_GE; }
 			)
 			r = addExpr
 			{ x = new ExprBinary(x->getContext(), o, x, r); }
 		)*
 	;

addExpr returns [Expression *x] { x = NULL; Expression *r; int o = 0; }
 	:	x=multExpr
 		(	( PLUS  { o = ExprBinary::BINOP_ADD; }
 			| MINUS { o = ExprBinary::BINOP_SUB; }
 			)
 			r=multExpr
 			{ x = new ExprBinary(x->getContext(), o, x, r); }
 		)*
 	;

multExpr returns [Expression *x] { x = NULL; Expression *r; int o = 0; }
 	:	x=castExpr
 		(	( STAR { o = ExprBinary::BINOP_MUL; }
 			| DIV  { o = ExprBinary::BINOP_DIV; }
 			| MOD  { o = ExprBinary::BINOP_MOD; }
 			| LSHIFT { o = ExprBinary::BINOP_LSHIFT; }
 			| RSHIFT { o = ExprBinary::BINOP_RSHIFT; }
 			)
 			r=castExpr
 			{ x = new ExprBinary(x->getContext(), o, x, r); }
 		)*
 	;

castExpr returns [Expression *x] { x = NULL; Type *t=NULL; }
 	:	(LPAREN primitive_type) =>
 		  (l:LPAREN t=primitive_type RPAREN) x=inc_dec_expr
 		{ x = new ExprTypeCast(getContext(l), t, x); }
 	|	x=inc_dec_expr
 	;

inc_dec_expr returns [Expression *x] { x = NULL; }
 	:	(incOrDec) => x=incOrDec
 	|	b:BANG x=value_expr { x = new ExprUnary(getContext(b), ExprUnary::UNOP_NOT, x); }
 	|	x=value_expr
 	;

incOrDec returns [Expression *x] { x = NULL; }
 	:	x=left_expr
 		(	INCREMENT
 			{ x = new ExprUnary(x->getContext(), ExprUnary::UNOP_POSTINC, x); }
 		|	DECREMENT
 			{ x = new ExprUnary(x->getContext(), ExprUnary::UNOP_POSTDEC, x); }
 		)
 	|	i:INCREMENT x=left_expr
 			{ x = new ExprUnary(getContext(i), ExprUnary::UNOP_PREINC, x); }
 	|	d:DECREMENT x=left_expr
 			{ x = new ExprUnary(getContext(d), ExprUnary::UNOP_PREDEC, x); }
 	;

value_expr returns [Expression *x] { x = NULL; bool neg = false; }
 	:	(m:MINUS { neg = true; })?
 		(x=minic_value_expr | x=streamit_value_expr)
 		{ if (neg) x = new ExprUnary(getContext(m), ExprUnary::UNOP_NEG, x); }
 	|	c:BITWISE_COMPLEMENT x=value_expr { x = new ExprUnary(getContext(c), ExprUnary::UNOP_COMPLEMENT, x); }
 	;

streamit_value_expr returns [Expression *x] { x = NULL; }
 	:	t:TK_pop LPAREN RPAREN
 			{ x = new ExprPop(getContext(t)); }
 	|	u:TK_peek LPAREN x=right_expr RPAREN
 			{ x = new ExprPeek(getContext(u), x); }
 	;

minic_value_expr returns [Expression *x] { x = NULL; }
 	:	LPAREN x=right_expr RPAREN
 	|	(func_call) => x=func_call
 	|	(helper_call) => x=helper_call
 	|	x=value
 	|	x=constantExpr
 	;

value returns [Expression *x] { x = NULL; Expression *array; }
 	:	name:ID { x = new ExprVar(getContext(name), name->getText()); }
 		(	DOT field:ID
 			{ x = new ExprField(x->getContext(), x, field->getText()); }
 		|	l:LSQUARE

 			(array=right_expr { x = new ExprArray(x->getContext(), x, array); }
// 			| { throw new SemanticException("missing array index",
// 						getFilename(), l.getLine()); }
			| { assert("missing array index" && 0); }
 			)
 			RSQUARE
 		)*
 	;

constantExpr returns [Expression *x] { x = NULL; }
 	:	h:HEXNUMBER
 			{ x = ExprConstant::createConstant(getContext(h), h->getText()); }
     //        String tmp = h.getText().substring(2);
 	 //    	   Integer iti = new Integer(
 	 // (int ) ( ( Long.parseLong(tmp, 16) - (long) Integer.MIN_VALUE ) 
 	 //      % ( (long)Integer.MAX_VALUE - (long) Integer.MIN_VALUE + 1) 
 	 //      + Integer.MIN_VALUE) );
 	 //    		x = ExprConstant.createConstant(getContext(h), iti.toString() ); }
    |	n:NUMBER
 			{ x = ExprConstant::createConstant(getContext(n), n->getText()); }
 	|	c:CHAR_LITERAL
 			{ x = new ExprConstChar(getContext(c), c->getText()); }
 	|	s:STRING_LITERAL
 			{ string str(s->getText());
              str.erase(str.begin());
              str.erase(str.end()-1);
              x = new ExprConstStr(getContext(s), str); }
	|	pi:TK_pi
			{ x = new ExprConstFloat(getContext(pi), M_PI); }
 	|	t:TK_true
 			{ x = new ExprConstBoolean(getContext(t), true); }
 	|	f:TK_false
 			{ x = new ExprConstBoolean(getContext(f), false); }
 	;

struct_decl returns [TypeStruct *ts]
{ ts = NULL; Parameter *p; NameList *names = new NameList;
 	TypeList *types = new TypeList; }
 	:	t:TK_struct id:ID
 		LCURLY
 		(p=param_decl SEMI
 			{ names->push_back(p->getName()); types->push_back(p->getType()); }
 		)*
 		RCURLY
 		{ ts = new TypeStruct(getContext(t), id->getText(), names, types); }
 	;

native_function_decl returns [Function *f] { Type *t; ParameterList *l; /*Statement *s;*/ f = NULL;
int cls = Function::FUNC_NATIVE; }
 	:	t=data_type id:ID l=param_decl_list SEMI
 		{ f = new Function(getContext(id), cls, id->getText(), t, l, NULL, NULL, NULL, NULL); }
 	;
	
native_decl returns [TypeHelper *th]
{ th = NULL; FunctionList *funcs = new FunctionList; Function *fn; 
  int cls = TypeHelper::NATIVE_HELPERS; }
 	:	t:TK_native id:ID
 		LCURLY
 		(
 		  (data_type ID LPAREN) => (fn=native_function_decl) { funcs->push_back(fn); }
 		)*
 		RCURLY
 		{ th = new TypeHelper(getContext(t), id->getText(), funcs, cls); }
 	;
		
helper_decl returns [TypeHelper *th]
{ th = NULL; FunctionList *funcs = new FunctionList; Function *fn; }
 	:	t:TK_helper id:ID
 		LCURLY
 		(
 		  (data_type ID LPAREN) => (fn=function_decl) { funcs->push_back(fn); }
 		)*
 		RCURLY
 		{ th = new TypeHelper(getContext(t), id->getText(), funcs); }
 	;
        
